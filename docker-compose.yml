# Definimos los servicios que vamos a tener
services:
  # Primer servicio
  iptables:
    # Indicamos que se debe de construir la imagen para este servicio
    build:
      # El Dockerfile se encuentra en este directorio
      context: ./ipTables # Especificamos el nombre del archivo dentro del directorio (contexto)
      dockerfile: Dockerfile
    # Nos permite agregar ciertos privilegios sobre la maquina anfitriona (SUPER IMPORTANTE PERO TAMBIÉN PUEDE LLEGAR A SER PELIGROSO)
    cap_add:
    # Para poder realizar operaciones relacionadas con la red
    - NET_ADMIN
    # Para poder realizar operaciones relacionadas con los paquetes de red
    - NET_RAW
    # Esto se hace para que el contenedor utilice "la pila de red" del host, esta pila de red es un conjunto de protocolos de comunicación
    # organizados en capas
    network_mode: "host"
    # Solo se va a reiniciar si se detiene con un código de error distinto a cero (indicando que hubo un error)
    restart: on-failure
    # Comando que se ejecutara al iniciar el contenedor
    command: ["/bin/bash", "./ipTablesConf.sh"]

  # Segundo servicio
  bind:
    # Indicamos que se debe de construir la imagen para este servicio
    build:
      # El Dockerfile se encuentra en este directorio
      context: ./DNSbind
      # Especificamos el nombre del archivo dentro del directorio (contexto)
      dockerfile: Dockerfile
    # Para que el puerto del contenedor (el que expusimos) sea accesible desde la maquina anfitriona, a esto se le llama "mapear un puerto",
    # en este caso del host al puerto del contenedor, es como si fuera un puente entre estos 2 puertos
    ports:
      # Utilizamos 127.0.0.1 ya que es el "localhost" de la maquina anfitriona (para que este contenedor solo sea accesible desde esta)
      # Formato PUERTO_HOST:PUERTO_CONTENEDOR para tcp y udp ya que este contenedor expone estos 2 puertos
      - "127.0.0.1:53:53/tcp"
      - "127.0.0.1:53:53/udp"
    # Le asignamos una IP estática al contenedor dentro de la red llamada "proyecto" (declarada después)
    networks:
      proyecto:
        ipv4_address: 192.168.0.2 # IP asignada al servidor BIND, por ende, la IP de nuestro DNS
    # Definimos el orden de inicio para nuestros servicios, en donde iptables debe de estar iniciado antes de que BIND pueda estarlo        
    depends_on:
      - iptables
    # Siempre se reiniciara el contenedor si este se detiene
    restart: always

  # Tercer servicio
  apache:
    # Indicamos que se debe de construir la imagen para este servicio
    build:
      # El Dockerfile se encuentra en este directorio
      context: ./virtualHostApache
      # Especificamos el nombre del archivo dentro del directorio (contexto) 
      dockerfile: Dockerfile
    # Para que el puerto del contenedor (el que expusimos) sea accesible desde la maquina anfitriona, a esto se le llama "mapear un puerto",
    # en este caso del host al puerto del contenedor, es como si fuera un puente entre estos 2 puertos
    ports:
      - "80:80" # Formato PUERTO_HOST:CONTENEDOR_HOST
    # Le asignamos una IP estática al contenedor dentro de la red llamada "proyecto" (declarada después)      
    networks:
      proyecto:
        ipv4_address: 192.168.0.3 # IP asignada al servidor Apache
    # Utilizamos el servidor BIND para nuestro DNS
    dns:
      - 192.168.0.2
    # Definimos el orden de inicio para nuestros servicios
    depends_on:
      - iptables
      - bind
    # Siempre se reiniciara el contenedor si este se detiene
    restart: always

  # Cuarto servicio
  squid:
    # Indicamos que se debe de construir la imagen para este servicio
    build:
      # El Dockerfile se encuentra en este directorio
      context: ./proxySquid
      # Especificamos el nombre del archivo dentro del directorio (contexto)
      dockerfile: Dockerfile
    # Para que el puerto del contenedor (el que expusimos) sea accesible desde la maquina anfitriona, a esto se le llama "mapear un puerto",
    # en este caso del host al puerto del contenedor, es como si fuera un puente entre estos 2 puertos
    ports:
      - "3128:3128" # Formato PUERTO_HOST:CONTENEDOR_HOST
    # Agregamos nuestra red llamada "proyecto" (declarada después)
    networks:
      - proyecto
    # Utilizamos el servidor BIND para nuestro DNS
    dns:
      - 192.168.0.2
    # Definimos el orden de inicio para nuestros servicios
    depends_on:
      - iptables
      - bind
      - apache
    # Siempre se reiniciara el contenedor si este se detiene
    restart: always


# Creamos nuestra red
networks:
  proyecto:
    # Ver https://shorturl.at/QFH4A para mejor entendimiento sobre este driver
    driver: bridge
    # IP address management nos deja configurar como se asignan las direcciones en la red
    ipam:
      config:
        # Definimos el rengo de direcciones, en este caso utilizamos /24 pero en realidad puede ser como sea
        - subnet: 192.168.0.0/24
          # Especifica la dirección IP de la puerta de enlace para esta subred
          gateway: 192.168.0.1